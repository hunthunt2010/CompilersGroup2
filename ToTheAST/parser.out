Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> START
Rule 1     START -> STMTS
Rule 2     STMTS -> STMT STMTS
Rule 3     STMTS -> <empty>
Rule 4     STMT -> DECL semi
Rule 5     STMT -> EXPR semi
Rule 6     STMT -> RETURN semi
Rule 7     STMT -> identifier assign EXPR semi
Rule 8     STMT -> if lp EXPR rp CODEBLOCK
Rule 9     STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK
Rule 10    DECL -> TYPE VARIABLE MULTI
Rule 11    DECL -> TYPE VARIABLE assign EXPR MULTI
Rule 12    MULTI -> comma VARIABLE MULTI
Rule 13    MULTI -> comma VARIABLE assign EXPR MULTI
Rule 14    MULTI -> <empty>
Rule 15    VARIABLE -> identifier
Rule 16    EXPR -> lp EXPR rp
Rule 17    EXPR -> EXPR BINARYOPERATOR EXPR
Rule 18    EXPR -> VALUE
Rule 19    BINARYOPERATOR -> leftshift
Rule 20    BINARYOPERATOR -> plus
Rule 21    BINARYOPERATOR -> minus
Rule 22    BINARYOPERATOR -> multiply
Rule 23    BINARYOPERATOR -> divide
Rule 24    BINARYOPERATOR -> lessequal
Rule 25    RETURN -> return
Rule 26    RETURN -> return EXPR
Rule 27    CODEBLOCK -> lb STMTS rb
Rule 28    VALUE -> int_value
Rule 29    VALUE -> identifier
Rule 30    TYPE -> MODIFIER TYPE
Rule 31    TYPE -> int
Rule 32    MODIFIER -> const

Terminals, with rules where they appear

assign               : 7 11 13
comma                : 12 13
const                : 32
divide               : 23
else                 : 9
error                : 
identifier           : 7 15 29
if                   : 8 9
int                  : 31
int_value            : 28
lb                   : 27
leftshift            : 19
lessequal            : 24
lp                   : 8 9 16
minus                : 21
multiply             : 22
plus                 : 20
rb                   : 27
return               : 25 26
rp                   : 8 9 16
semi                 : 4 5 6 7

Nonterminals, with rules where they appear

BINARYOPERATOR       : 17
CODEBLOCK            : 8 9 9
DECL                 : 4
EXPR                 : 5 7 8 9 11 13 16 17 17 26
MODIFIER             : 30
MULTI                : 10 11 12 13
RETURN               : 6
START                : 0
STMT                 : 2
STMTS                : 1 2 27
TYPE                 : 10 11 30
VALUE                : 18
VARIABLE             : 10 11 12 13

Parsing method: LALR

state 0

    (0) S' -> . START
    (1) START -> . STMTS
    (2) STMTS -> . STMT STMTS
    (3) STMTS -> .
    (4) STMT -> . DECL semi
    (5) STMT -> . EXPR semi
    (6) STMT -> . RETURN semi
    (7) STMT -> . identifier assign EXPR semi
    (8) STMT -> . if lp EXPR rp CODEBLOCK
    (9) STMT -> . if lp EXPR rp CODEBLOCK else CODEBLOCK
    (10) DECL -> . TYPE VARIABLE MULTI
    (11) DECL -> . TYPE VARIABLE assign EXPR MULTI
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (25) RETURN -> . return
    (26) RETURN -> . return EXPR
    (30) TYPE -> . MODIFIER TYPE
    (31) TYPE -> . int
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier
    (32) MODIFIER -> . const

    $end            reduce using rule 3 (STMTS -> .)
    identifier      shift and go to state 11
    if              shift and go to state 15
    lp              shift and go to state 7
    return          shift and go to state 4
    int             shift and go to state 3
    int_value       shift and go to state 8
    const           shift and go to state 13

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 2
    START                          shift and go to state 10
    RETURN                         shift and go to state 12
    DECL                           shift and go to state 5
    STMT                           shift and go to state 6
    STMTS                          shift and go to state 14
    TYPE                           shift and go to state 9
    MODIFIER                       shift and go to state 16

state 1

    (18) EXPR -> VALUE .

    semi            reduce using rule 18 (EXPR -> VALUE .)
    leftshift       reduce using rule 18 (EXPR -> VALUE .)
    plus            reduce using rule 18 (EXPR -> VALUE .)
    minus           reduce using rule 18 (EXPR -> VALUE .)
    multiply        reduce using rule 18 (EXPR -> VALUE .)
    divide          reduce using rule 18 (EXPR -> VALUE .)
    lessequal       reduce using rule 18 (EXPR -> VALUE .)
    comma           reduce using rule 18 (EXPR -> VALUE .)
    rp              reduce using rule 18 (EXPR -> VALUE .)


state 2

    (5) STMT -> EXPR . semi
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    semi            shift and go to state 22
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    BINARYOPERATOR                 shift and go to state 23

state 3

    (31) TYPE -> int .

    identifier      reduce using rule 31 (TYPE -> int .)


state 4

    (25) RETURN -> return .
    (26) RETURN -> return . EXPR
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    semi            reduce using rule 25 (RETURN -> return .)
    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 25

state 5

    (4) STMT -> DECL . semi

    semi            shift and go to state 27


state 6

    (2) STMTS -> STMT . STMTS
    (2) STMTS -> . STMT STMTS
    (3) STMTS -> .
    (4) STMT -> . DECL semi
    (5) STMT -> . EXPR semi
    (6) STMT -> . RETURN semi
    (7) STMT -> . identifier assign EXPR semi
    (8) STMT -> . if lp EXPR rp CODEBLOCK
    (9) STMT -> . if lp EXPR rp CODEBLOCK else CODEBLOCK
    (10) DECL -> . TYPE VARIABLE MULTI
    (11) DECL -> . TYPE VARIABLE assign EXPR MULTI
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (25) RETURN -> . return
    (26) RETURN -> . return EXPR
    (30) TYPE -> . MODIFIER TYPE
    (31) TYPE -> . int
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier
    (32) MODIFIER -> . const

    $end            reduce using rule 3 (STMTS -> .)
    rb              reduce using rule 3 (STMTS -> .)
    identifier      shift and go to state 11
    if              shift and go to state 15
    lp              shift and go to state 7
    return          shift and go to state 4
    int             shift and go to state 3
    int_value       shift and go to state 8
    const           shift and go to state 13

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 2
    RETURN                         shift and go to state 12
    DECL                           shift and go to state 5
    STMT                           shift and go to state 6
    STMTS                          shift and go to state 28
    TYPE                           shift and go to state 9
    MODIFIER                       shift and go to state 16

state 7

    (16) EXPR -> lp . EXPR rp
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 29

state 8

    (28) VALUE -> int_value .

    rp              reduce using rule 28 (VALUE -> int_value .)
    leftshift       reduce using rule 28 (VALUE -> int_value .)
    plus            reduce using rule 28 (VALUE -> int_value .)
    minus           reduce using rule 28 (VALUE -> int_value .)
    multiply        reduce using rule 28 (VALUE -> int_value .)
    divide          reduce using rule 28 (VALUE -> int_value .)
    lessequal       reduce using rule 28 (VALUE -> int_value .)
    semi            reduce using rule 28 (VALUE -> int_value .)
    comma           reduce using rule 28 (VALUE -> int_value .)


state 9

    (10) DECL -> TYPE . VARIABLE MULTI
    (11) DECL -> TYPE . VARIABLE assign EXPR MULTI
    (15) VARIABLE -> . identifier

    identifier      shift and go to state 31

    VARIABLE                       shift and go to state 30

state 10

    (0) S' -> START .



state 11

    (7) STMT -> identifier . assign EXPR semi
    (29) VALUE -> identifier .

    assign          shift and go to state 32
    semi            reduce using rule 29 (VALUE -> identifier .)
    leftshift       reduce using rule 29 (VALUE -> identifier .)
    plus            reduce using rule 29 (VALUE -> identifier .)
    minus           reduce using rule 29 (VALUE -> identifier .)
    multiply        reduce using rule 29 (VALUE -> identifier .)
    divide          reduce using rule 29 (VALUE -> identifier .)
    lessequal       reduce using rule 29 (VALUE -> identifier .)


state 12

    (6) STMT -> RETURN . semi

    semi            shift and go to state 33


state 13

    (32) MODIFIER -> const .

    int             reduce using rule 32 (MODIFIER -> const .)
    const           reduce using rule 32 (MODIFIER -> const .)


state 14

    (1) START -> STMTS .

    $end            reduce using rule 1 (START -> STMTS .)


state 15

    (8) STMT -> if . lp EXPR rp CODEBLOCK
    (9) STMT -> if . lp EXPR rp CODEBLOCK else CODEBLOCK

    lp              shift and go to state 34


state 16

    (30) TYPE -> MODIFIER . TYPE
    (30) TYPE -> . MODIFIER TYPE
    (31) TYPE -> . int
    (32) MODIFIER -> . const

    int             shift and go to state 3
    const           shift and go to state 13

    TYPE                           shift and go to state 35
    MODIFIER                       shift and go to state 16

state 17

    (24) BINARYOPERATOR -> lessequal .

    lp              reduce using rule 24 (BINARYOPERATOR -> lessequal .)
    int_value       reduce using rule 24 (BINARYOPERATOR -> lessequal .)
    identifier      reduce using rule 24 (BINARYOPERATOR -> lessequal .)


state 18

    (22) BINARYOPERATOR -> multiply .

    lp              reduce using rule 22 (BINARYOPERATOR -> multiply .)
    int_value       reduce using rule 22 (BINARYOPERATOR -> multiply .)
    identifier      reduce using rule 22 (BINARYOPERATOR -> multiply .)


state 19

    (20) BINARYOPERATOR -> plus .

    lp              reduce using rule 20 (BINARYOPERATOR -> plus .)
    int_value       reduce using rule 20 (BINARYOPERATOR -> plus .)
    identifier      reduce using rule 20 (BINARYOPERATOR -> plus .)


state 20

    (21) BINARYOPERATOR -> minus .

    lp              reduce using rule 21 (BINARYOPERATOR -> minus .)
    int_value       reduce using rule 21 (BINARYOPERATOR -> minus .)
    identifier      reduce using rule 21 (BINARYOPERATOR -> minus .)


state 21

    (23) BINARYOPERATOR -> divide .

    lp              reduce using rule 23 (BINARYOPERATOR -> divide .)
    int_value       reduce using rule 23 (BINARYOPERATOR -> divide .)
    identifier      reduce using rule 23 (BINARYOPERATOR -> divide .)


state 22

    (5) STMT -> EXPR semi .

    identifier      reduce using rule 5 (STMT -> EXPR semi .)
    if              reduce using rule 5 (STMT -> EXPR semi .)
    lp              reduce using rule 5 (STMT -> EXPR semi .)
    return          reduce using rule 5 (STMT -> EXPR semi .)
    int             reduce using rule 5 (STMT -> EXPR semi .)
    int_value       reduce using rule 5 (STMT -> EXPR semi .)
    const           reduce using rule 5 (STMT -> EXPR semi .)
    $end            reduce using rule 5 (STMT -> EXPR semi .)
    rb              reduce using rule 5 (STMT -> EXPR semi .)


state 23

    (17) EXPR -> EXPR BINARYOPERATOR . EXPR
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 36

state 24

    (19) BINARYOPERATOR -> leftshift .

    lp              reduce using rule 19 (BINARYOPERATOR -> leftshift .)
    int_value       reduce using rule 19 (BINARYOPERATOR -> leftshift .)
    identifier      reduce using rule 19 (BINARYOPERATOR -> leftshift .)


state 25

    (26) RETURN -> return EXPR .
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    semi            reduce using rule 26 (RETURN -> return EXPR .)
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    BINARYOPERATOR                 shift and go to state 23

state 26

    (29) VALUE -> identifier .

    rp              reduce using rule 29 (VALUE -> identifier .)
    leftshift       reduce using rule 29 (VALUE -> identifier .)
    plus            reduce using rule 29 (VALUE -> identifier .)
    minus           reduce using rule 29 (VALUE -> identifier .)
    multiply        reduce using rule 29 (VALUE -> identifier .)
    divide          reduce using rule 29 (VALUE -> identifier .)
    lessequal       reduce using rule 29 (VALUE -> identifier .)
    semi            reduce using rule 29 (VALUE -> identifier .)
    comma           reduce using rule 29 (VALUE -> identifier .)


state 27

    (4) STMT -> DECL semi .

    identifier      reduce using rule 4 (STMT -> DECL semi .)
    if              reduce using rule 4 (STMT -> DECL semi .)
    lp              reduce using rule 4 (STMT -> DECL semi .)
    return          reduce using rule 4 (STMT -> DECL semi .)
    int             reduce using rule 4 (STMT -> DECL semi .)
    int_value       reduce using rule 4 (STMT -> DECL semi .)
    const           reduce using rule 4 (STMT -> DECL semi .)
    $end            reduce using rule 4 (STMT -> DECL semi .)
    rb              reduce using rule 4 (STMT -> DECL semi .)


state 28

    (2) STMTS -> STMT STMTS .

    $end            reduce using rule 2 (STMTS -> STMT STMTS .)
    rb              reduce using rule 2 (STMTS -> STMT STMTS .)


state 29

    (16) EXPR -> lp EXPR . rp
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    rp              shift and go to state 37
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    BINARYOPERATOR                 shift and go to state 23

state 30

    (10) DECL -> TYPE VARIABLE . MULTI
    (11) DECL -> TYPE VARIABLE . assign EXPR MULTI
    (12) MULTI -> . comma VARIABLE MULTI
    (13) MULTI -> . comma VARIABLE assign EXPR MULTI
    (14) MULTI -> .

    assign          shift and go to state 40
    comma           shift and go to state 39
    semi            reduce using rule 14 (MULTI -> .)

    MULTI                          shift and go to state 38

state 31

    (15) VARIABLE -> identifier .

    assign          reduce using rule 15 (VARIABLE -> identifier .)
    comma           reduce using rule 15 (VARIABLE -> identifier .)
    semi            reduce using rule 15 (VARIABLE -> identifier .)


state 32

    (7) STMT -> identifier assign . EXPR semi
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 41

state 33

    (6) STMT -> RETURN semi .

    identifier      reduce using rule 6 (STMT -> RETURN semi .)
    if              reduce using rule 6 (STMT -> RETURN semi .)
    lp              reduce using rule 6 (STMT -> RETURN semi .)
    return          reduce using rule 6 (STMT -> RETURN semi .)
    int             reduce using rule 6 (STMT -> RETURN semi .)
    int_value       reduce using rule 6 (STMT -> RETURN semi .)
    const           reduce using rule 6 (STMT -> RETURN semi .)
    $end            reduce using rule 6 (STMT -> RETURN semi .)
    rb              reduce using rule 6 (STMT -> RETURN semi .)


state 34

    (8) STMT -> if lp . EXPR rp CODEBLOCK
    (9) STMT -> if lp . EXPR rp CODEBLOCK else CODEBLOCK
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 42

state 35

    (30) TYPE -> MODIFIER TYPE .

    identifier      reduce using rule 30 (TYPE -> MODIFIER TYPE .)


state 36

    (17) EXPR -> EXPR BINARYOPERATOR EXPR .
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

  ! shift/reduce conflict for leftshift resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for multiply resolved as shift
  ! shift/reduce conflict for divide resolved as shift
  ! shift/reduce conflict for lessequal resolved as shift
    semi            reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .)
    comma           reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .)
    rp              reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .)
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

  ! leftshift       [ reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .) ]
  ! plus            [ reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .) ]
  ! minus           [ reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .) ]
  ! multiply        [ reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .) ]
  ! divide          [ reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .) ]
  ! lessequal       [ reduce using rule 17 (EXPR -> EXPR BINARYOPERATOR EXPR .) ]

    BINARYOPERATOR                 shift and go to state 23

state 37

    (16) EXPR -> lp EXPR rp .

    semi            reduce using rule 16 (EXPR -> lp EXPR rp .)
    leftshift       reduce using rule 16 (EXPR -> lp EXPR rp .)
    plus            reduce using rule 16 (EXPR -> lp EXPR rp .)
    minus           reduce using rule 16 (EXPR -> lp EXPR rp .)
    multiply        reduce using rule 16 (EXPR -> lp EXPR rp .)
    divide          reduce using rule 16 (EXPR -> lp EXPR rp .)
    lessequal       reduce using rule 16 (EXPR -> lp EXPR rp .)
    comma           reduce using rule 16 (EXPR -> lp EXPR rp .)
    rp              reduce using rule 16 (EXPR -> lp EXPR rp .)


state 38

    (10) DECL -> TYPE VARIABLE MULTI .

    semi            reduce using rule 10 (DECL -> TYPE VARIABLE MULTI .)


state 39

    (12) MULTI -> comma . VARIABLE MULTI
    (13) MULTI -> comma . VARIABLE assign EXPR MULTI
    (15) VARIABLE -> . identifier

    identifier      shift and go to state 31

    VARIABLE                       shift and go to state 43

state 40

    (11) DECL -> TYPE VARIABLE assign . EXPR MULTI
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    EXPR                           shift and go to state 44
    VALUE                          shift and go to state 1

state 41

    (7) STMT -> identifier assign EXPR . semi
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    semi            shift and go to state 45
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    BINARYOPERATOR                 shift and go to state 23

state 42

    (8) STMT -> if lp EXPR . rp CODEBLOCK
    (9) STMT -> if lp EXPR . rp CODEBLOCK else CODEBLOCK
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    rp              shift and go to state 46
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    BINARYOPERATOR                 shift and go to state 23

state 43

    (12) MULTI -> comma VARIABLE . MULTI
    (13) MULTI -> comma VARIABLE . assign EXPR MULTI
    (12) MULTI -> . comma VARIABLE MULTI
    (13) MULTI -> . comma VARIABLE assign EXPR MULTI
    (14) MULTI -> .

    assign          shift and go to state 48
    comma           shift and go to state 39
    semi            reduce using rule 14 (MULTI -> .)

    MULTI                          shift and go to state 47

state 44

    (11) DECL -> TYPE VARIABLE assign EXPR . MULTI
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (12) MULTI -> . comma VARIABLE MULTI
    (13) MULTI -> . comma VARIABLE assign EXPR MULTI
    (14) MULTI -> .
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    comma           shift and go to state 39
    semi            reduce using rule 14 (MULTI -> .)
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    MULTI                          shift and go to state 49
    BINARYOPERATOR                 shift and go to state 23

state 45

    (7) STMT -> identifier assign EXPR semi .

    identifier      reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    if              reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    lp              reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    return          reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    int             reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    int_value       reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    const           reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    $end            reduce using rule 7 (STMT -> identifier assign EXPR semi .)
    rb              reduce using rule 7 (STMT -> identifier assign EXPR semi .)


state 46

    (8) STMT -> if lp EXPR rp . CODEBLOCK
    (9) STMT -> if lp EXPR rp . CODEBLOCK else CODEBLOCK
    (27) CODEBLOCK -> . lb STMTS rb

    lb              shift and go to state 50

    CODEBLOCK                      shift and go to state 51

state 47

    (12) MULTI -> comma VARIABLE MULTI .

    semi            reduce using rule 12 (MULTI -> comma VARIABLE MULTI .)


state 48

    (13) MULTI -> comma VARIABLE assign . EXPR MULTI
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier

    lp              shift and go to state 7
    int_value       shift and go to state 8
    identifier      shift and go to state 26

    EXPR                           shift and go to state 52
    VALUE                          shift and go to state 1

state 49

    (11) DECL -> TYPE VARIABLE assign EXPR MULTI .

    semi            reduce using rule 11 (DECL -> TYPE VARIABLE assign EXPR MULTI .)


state 50

    (27) CODEBLOCK -> lb . STMTS rb
    (2) STMTS -> . STMT STMTS
    (3) STMTS -> .
    (4) STMT -> . DECL semi
    (5) STMT -> . EXPR semi
    (6) STMT -> . RETURN semi
    (7) STMT -> . identifier assign EXPR semi
    (8) STMT -> . if lp EXPR rp CODEBLOCK
    (9) STMT -> . if lp EXPR rp CODEBLOCK else CODEBLOCK
    (10) DECL -> . TYPE VARIABLE MULTI
    (11) DECL -> . TYPE VARIABLE assign EXPR MULTI
    (16) EXPR -> . lp EXPR rp
    (17) EXPR -> . EXPR BINARYOPERATOR EXPR
    (18) EXPR -> . VALUE
    (25) RETURN -> . return
    (26) RETURN -> . return EXPR
    (30) TYPE -> . MODIFIER TYPE
    (31) TYPE -> . int
    (28) VALUE -> . int_value
    (29) VALUE -> . identifier
    (32) MODIFIER -> . const

    rb              reduce using rule 3 (STMTS -> .)
    identifier      shift and go to state 11
    if              shift and go to state 15
    lp              shift and go to state 7
    return          shift and go to state 4
    int             shift and go to state 3
    int_value       shift and go to state 8
    const           shift and go to state 13

    VALUE                          shift and go to state 1
    EXPR                           shift and go to state 2
    RETURN                         shift and go to state 12
    DECL                           shift and go to state 5
    STMT                           shift and go to state 6
    STMTS                          shift and go to state 53
    TYPE                           shift and go to state 9
    MODIFIER                       shift and go to state 16

state 51

    (8) STMT -> if lp EXPR rp CODEBLOCK .
    (9) STMT -> if lp EXPR rp CODEBLOCK . else CODEBLOCK

    identifier      reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    if              reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    lp              reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    return          reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    int             reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    int_value       reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    const           reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    $end            reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    rb              reduce using rule 8 (STMT -> if lp EXPR rp CODEBLOCK .)
    else            shift and go to state 54


state 52

    (13) MULTI -> comma VARIABLE assign EXPR . MULTI
    (17) EXPR -> EXPR . BINARYOPERATOR EXPR
    (12) MULTI -> . comma VARIABLE MULTI
    (13) MULTI -> . comma VARIABLE assign EXPR MULTI
    (14) MULTI -> .
    (19) BINARYOPERATOR -> . leftshift
    (20) BINARYOPERATOR -> . plus
    (21) BINARYOPERATOR -> . minus
    (22) BINARYOPERATOR -> . multiply
    (23) BINARYOPERATOR -> . divide
    (24) BINARYOPERATOR -> . lessequal

    comma           shift and go to state 39
    semi            reduce using rule 14 (MULTI -> .)
    leftshift       shift and go to state 24
    plus            shift and go to state 19
    minus           shift and go to state 20
    multiply        shift and go to state 18
    divide          shift and go to state 21
    lessequal       shift and go to state 17

    MULTI                          shift and go to state 55
    BINARYOPERATOR                 shift and go to state 23

state 53

    (27) CODEBLOCK -> lb STMTS . rb

    rb              shift and go to state 56


state 54

    (9) STMT -> if lp EXPR rp CODEBLOCK else . CODEBLOCK
    (27) CODEBLOCK -> . lb STMTS rb

    lb              shift and go to state 50

    CODEBLOCK                      shift and go to state 57

state 55

    (13) MULTI -> comma VARIABLE assign EXPR MULTI .

    semi            reduce using rule 13 (MULTI -> comma VARIABLE assign EXPR MULTI .)


state 56

    (27) CODEBLOCK -> lb STMTS rb .

    else            reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    identifier      reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    if              reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    lp              reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    return          reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    int             reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    int_value       reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    const           reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    $end            reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)
    rb              reduce using rule 27 (CODEBLOCK -> lb STMTS rb .)


state 57

    (9) STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .

    identifier      reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    if              reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    lp              reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    return          reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    int             reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    int_value       reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    const           reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    $end            reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)
    rb              reduce using rule 9 (STMT -> if lp EXPR rp CODEBLOCK else CODEBLOCK .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for leftshift in state 36 resolved as shift
WARNING: shift/reduce conflict for plus in state 36 resolved as shift
WARNING: shift/reduce conflict for minus in state 36 resolved as shift
WARNING: shift/reduce conflict for multiply in state 36 resolved as shift
WARNING: shift/reduce conflict for divide in state 36 resolved as shift
WARNING: shift/reduce conflict for lessequal in state 36 resolved as shift
